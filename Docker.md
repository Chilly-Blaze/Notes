# Docker

## 概述

*Docker 是一个开源的应用容器引擎，让开发者可以打包他们的应用以及依赖包到一个可移植的镜像中，然后发布到任何流行的 Linux或Windows操作系统的机器上，也可以实现虚拟化。容器是完全使用沙箱机制，相互之间不会有任何接口。*

<p align="right"><i>——百度百科</i></p>

看上去并不好理解，事实上以后当我们开发一个项目时，除了代码部分的内容（即jar包下内容），我们可能还需要配置很多的环境，比如mybatis简单的数据库连接项目你就必须下载mysql和maven等环境，我们这边跑起来没问题，一上线服务器或交给别人来运行，所有的内容又需要重新部署一边，更有可能出现不能跨平台等问题，费时费力，这时候就需要Docker帮忙了

Docker可以将我们用Java开发的项目包括所有环境直接打包，其中的环境部分就叫做镜像，Docker会提供一个仓库，相当于手机上的应用商店，将打包好的所有环境全部放进仓库中，当另一个下载者运行代码时需要某个环境，直接从仓库中下载即可

Docker还有一个特性就是环境隔离，在Docker仓库中，每一套环境都是相互不会影响的，这意味着如果将一个项目部署到服务器中，不同的环境相互不影响，可以进一步将服务器资源运用到极致

## 容器化/虚拟机技术

我们可能会发现Docker的运行原理似乎和虚拟机比较像，事实上也的确如此，都是提供了一个似乎虚拟的环境供我们使用，但是Docker强就强在它的轻量级

![image-20211114211121151.png](https://s2.loli.net/2021/12/06/nF1tf87EqmNXT2e.png)

其中库文件实际上就是各种环境，可能会有很多种环境相互之间互相混杂，所有的应用都要跑在这个环境上， 免不了会发生环境之间的冲突，同时虚拟机还可以类比于你自己的电脑，每一次的启动都需要花费大把时间，明明你可能只是想开电脑写一个日记，电脑不知道你的需求还是会勤勤恳恳的加载完所有可能需要运行的环境内容

![image-20211115102823673](https://s2.loli.net/2021/12/06/b4aIugeQ9mhAORl.png)

可以看出容器化之后每个应用程序都带着自己少量的环境运行，同时Docker本身不带内核（用的是宿主机的内核）的特性更加避免了启动内

z核时的繁琐，这样我们通过Docker打开某一个应用程序，只需要启动少量但必需的环境即可运行程序，再也不需要进行启动虚拟机或者打开电脑动辄就是几分钟的加载环境过程

同时还有一点就是容器化的技术可以避免像虚拟机一样一堆环境耦合在一起，万一某两个环境冲突了找问题都要找半天，容器化之后，就算你两个容器中都下载了同一个环境，由于容器之间的隔离性，也永远不用担心环境崩溃

## 安装

首先我们要了解到Docker支持的只有Linux系统，如果我们想要在Windows内装Docker还需要装WSL（虚拟机环境），显得得不偿失了，因此我们需要一台虚拟机或者是服务器供我们测试Docker的使用

> 此处使用的是termius连接甲骨文云英国VPS内置的CentOS8系统，Docker[官方文档](https://docs.docker.com/)中也指明了支持的系统类型
>
> ![image-20211115183439983](https://s2.loli.net/2021/12/06/uxKY5WbMeyjv1qP.png)

同时在安装之前我们还是需要通过`cat /etc/os-release`来确定一下自己系统的一些内核即其他环境的配置信息

*To install Docker Engine, you need a maintained version of CentOS 7 or 8. Archived versions aren’t supported or tested.*官方文档中也明确了不会支持CentOS7以下的系统

![image-20211115184748147](https://s2.loli.net/2021/12/06/ALKeFI13oHYzv8R.png)

接着我们就可以开始愉快的安装了，其中官方文档写的非常详细，跟着他一步步来即可

1. 删除原有旧版Docker

   ```shell
   yum remove docker \
                     docker-client \
                     docker-client-latest \
                     docker-common \
                     docker-latest \
                     docker-latest-logrotate \
                     docker-logrotate \
                     docker-engine
   ```

2. 下载`yum-utils`工具包（用于维护yum软件包）及添加固定的Docker镜像仓库（此处可以选用国内镜像源）

   ```shell
   yum install -y yum-utils
   
   yum-config-manager \
       --add-repo \
       https://download.docker.com/linux/centos/docker-ce.repo
   ```

   

   ```shell
   yum erase podman buildah
   ```

3. 安装Docker引擎

   ```shell
   yum install docker
   ```

   >注意，CentOS8默认使用的是podman容器化技术，因此我们这里如果输成了`yum install docker`则会下到一堆不认识的东西，后面的内容也直接无法进行，如果手贱的话我们就执行`sudo yum erase podman buildah`卸载相关内容
   >
   ><img src="https://s2.loli.net/2021/12/06/F8xySnC69fg3NdR.png" alt="image-20211115192201173" style="zoom: 33%;" />

4. 启动Docker并测试是否安装成功

   ```shell
   systemctl start docker
   docker version
   ```

   ![image-20211115192748059](https://s2.loli.net/2021/12/06/7L38yYQHRPjfu4g.png)

   ```bash
   systemctl enable docker.service  # 开机自启
   ```

5. 测试运行`hello-world`

   ![image-20211115194442185](https://s2.loli.net/2021/12/06/myLS3ZwWrNuGdM8.png)

   这时候我们看着这个详细的四步解释运行原理，我们能够更加深刻的认识到Docker的运行原理

   ![731fc8043e0f71aab7851ad87427bdd6](https://s2.loli.net/2021/12/07/Nhi2vKtQYq7kxRu.png)

   我们输入命令的工具称之为客户端 Client，当我们在客户端输入命令时，命令会发送到 docker 所在主机的 daemon 进程，由该进程执行命令。当执行的是创建容器的命令时，如果对应的镜像不存在于本地，那么 daemon 会向远程 docker 仓库请求下载镜像，等镜像下载到本地后在创建容器。

   > 注意容器和镜像的关系就像是对象和类，镜像创建一个个容器就像是类实例化一个个对象

6. 为了验证我们的判断，我们可以查看刚刚下载到的hello-world镜像

   ![image-20211115202451021](https://s2.loli.net/2021/12/06/Kx4bnmJT8UsRCoE.png)

这样我们的一个最简单的Docker项目流程就完成了

## 镜像/容器控制常用命令

和git一样，所有的Docker命令都是`docker`开头的，下面的命令也都省略了前置的`docker`

同时所有的命令都可以在[文档](https://docs.docker.com/engine/reference/commandline/docker/)中找到，下面只列举常用指令的部分信息，同时下面是看帮助文档的方法

![image-20211115223820122](https://s2.loli.net/2021/12/06/qBMDzdgThE5rKxj.png)

- `[命令] --help`帮助命令，什么不会就查什么

- `info`比`version`更详细的Docker信息

- `search [镜像名称]`搜索某个镜像（类比于Github搜索仓库）

- `pull [镜像名称]`下载镜像，同时可以通过后面`:[版本号]`来指定下载版本（默认是最新版）

  > 当然版本也不能乱定，所有镜像的详细信息都可以在[DockerHub](https://hub.docker.com/)里面找到

- `rmi [镜像名称/ID]`删除下载到本地的镜像

上面的是有关镜像的命令，接下来通过在centos内再下一个ubuntu镜像来演示容器命令

![image-20211115214629480](https://s2.loli.net/2021/12/06/ldSGpkeqjhN25TM.png)

- `run`创建容器，上面提到过，容器和镜像就类比对象和类，本地的一个镜像并不能发生什么，想要让他起作用就必须把他run起来

  - `--name`容器名称（类比对象变量名）

  - `-d`后台方式运行

    > 注意到后台启动时如果前台没有应用需要它提供服务，Docker就会自动把他关闭掉

  - `-it`使用交互方式运行，进入容器查看内容

  - `-p [主机映射端口]:[容器端口]`指定容器的端口，也可以仅指定容器端口

    > 比如我们启动了一个Nginx服务，那么此时如果我们设定参数`81:80`意味着宿主机映射端口是81，在容器外部我们访问`localhost:81`可以访问到容器内部开启的Nginx服务，而在容器内部我们访问80，也可以访问到相同的Nginx服务

  - `-P`随机指定端口

    ![image-20211115215338581](https://s2.loli.net/2021/12/06/yMu4vHp5Sm3FVNW.png)

    > 由于`-it`是交互方式运行，因此必须指定相互方式，这里指定的是bash方式

  - `-e [参数名]=[参数数值]`配置一些环境信息，比如说MySQL启动时我们可能要设定用户名密码，ES启动时可能需要限制它能够占用内存大小，而它详细的参数还是需要在Dockerhub中看镜像的相关说明

    ![image-20211117210604713](https://s2.loli.net/2021/12/06/yOn3dSVaQvXMfZi.png)

  内部的环境和外部看上去是没有区别的，甚至你在里面`ls`也能看到根目录下的内容，但是毕竟是镜像，很多东西还是不完善的

- `exit`退出容器（由于现在可以当作运行在Ubuntu环境下，因此命令前面不需要加`docker`），同时一旦退出容器就停止运行，但并不是销毁容器

- `ps`当前在运行的容器，`-a`可以查看曾经运行过的容器

  ![image-20211115220435121](https://s2.loli.net/2021/12/06/xCRh9NWDmzLwtIS.png)

- `Ctrl + p + q`在容器内不停止容器退出，容器依旧在运行

- `rm [容器id]`删除曾经运行过的仍存在的容器，但是不能删除正在运行的容器，`-f`强制删除不管你在不再运行

- `start [容器id]`和Linux一样，开启一个被停止的容器，与此类似的还有`restart`、`stop`、`kill`等，像操作一个进程一样操作容器

- `logs [容器id]`查看目标容器运行时的日志记录

  ![image-20211115223150512](https://s2.loli.net/2021/12/06/7fbT6pEuvRJaixB.png)

- `top [容器id]`查看容器内部的进程信息（容器近似看作一个虚拟机，看的就是虚拟机内部的进程）

- `inspect [容器id]`查看容器的所有信息，会蹦出来一大堆JSON信息，先不着急看懂

- `exec`进入一个正在运行的容器，同样`-it`可以用交互方式运行

- `attach`也是进入一个容器，但是它一般不加参数，进入后如果容器内有某个终端正在执行就直接进入那个终端，而`exec`会重新开启一个终端

- `cp [容器id]:[容器内路径] [当前宿主机目标路径]`不管容器是否开启，都可以在容器外拷贝容器内的文件到容器外（宿主机上），当然交换一下参数内容也可以反向拷贝

## 联合文件系统（UnionFS）

比如当我们下载一个Mysql镜像时，会发现下载内容是呈现层级关系的

![image-20211117162053016](https://s2.loli.net/2021/12/06/ytEZ2aMQfqBnhTm.png)

看上去好像是一层一层逐级下载的，其实这就是Docker巧妙地利用了UnionFS联合文件系统办到的

联合文件系统事实上就是将一个镜像再次分成多个镜像小部件（比如nginx镜像可能就需要centos镜像的支持），如果两个镜像存在多个相同的小部件，只需要下载一次相同的部分，而对不同的部分再区分下载即可

上面的每一个哈希码就代表着目标镜像的子镜像，在下载之前Docker会自动检测当前本地是否存在相同的名称镜像，如果有就不需要额外下载，这样可以进一步的降低Docker的占用和提升运行性能

而且这种联合文件系统还可以使得比如我们需要在这个下载过来的nginx进行修改时，可以重新在这个nginx上面再加一层（容器层），而不是直接对原本的文件进行修改，当我们完成我们的配置之后把我们创建的层和原本的层一起打包成镜像，再传给别人的话，别人就可以拥有我们修改过的已经配置好所需项目环境的nginx内容了

![20160819173838](https://s2.loli.net/2021/12/06/sUQZ6E18rpae57I.png)

## 创建个性化镜像

了解了联合文件系统，接下来自然的我们就可以自己创建一个镜像

`docker commit -m=[提交信息] -a=[作者] [容器id] [目标镜像名]:[版本号] `提交容器成为一个自定义的镜像，和Github很像

之后通过`images`就可以看到提交上去的镜像信息

![image-20211117192308567](https://s2.loli.net/2021/12/06/nmWG3T8ONoPMsdA.png)

## 目录挂载

之前的操作还有一个问题，我们好像并不放心能够在这么一个开启后的容器中持久化存储数据，由于容器本身就是不完整的镜像启动的，难免我们不会手贱删除了某个容器，或是环境配着配着就崩了，导致环境中的数据根本不方便取出，Docker甚至不提供回收站的功能，容器没了就是没了，数据也直接丢失，等于删库跑路，为了避免这种情况的发生，我们需要一种方式在容器中调用本地的数据进行操作，容器只用装配环境，既解耦了数据和环境，又为我们的开发提供了更加安全的方式

这时候就需要用到容器数据卷这个概念，它可以把Docker容器中产生的数据同步到本地

卷技术的目标就是将容器中的目录**挂载**到LInux上面，是一种同步机制，不止是容器和宿主机的交互，甚至能做到隔离的容器间的数据同步，这也给我们的不同环境配置时环境的隔离和数据的统一提供了方案

想要采用容器数据卷技术，就需要在`run`时带上`-v [宿主机目录]:[容器内目录]`可选项，则可以将宿主机的某个目录能够同步容器内某个目录

![image-20211117200440548](https://s2.loli.net/2021/12/06/v1AhD5f2nH9drpB.png)

同时挂载并不是单向连接，除了图中的在容器内部修改会影响到宿主机，同样的宿主机test目录下修改内容也会让容器内相应目录变化，同时这样也意味着我们也可以在本地快捷的修改容器内的目录，实现了不用进容器就能够快速修改例如配置文件

但是注意如果我们删除了容器内的文件，外部文件也会消失，但是如果我们删除容器，外部目录的文件并不会消失

![image-20211117204904612](https://s2.loli.net/2021/12/06/LnAsC3fvBzH1JT6.png)

> 我们可能注意到，当我们已经启动了一个容器之后，好像就不能挂载目录了，事实上也是这样的，如果我们真的要一个已经创建过的容器里面的数据，可以采用`docker cp`指令拷出容器内的文件再删除容器

除了上面这样的挂载方式，我们可以不指定宿主机的目录路径，或者是用一个名称代替目录路径（即最前面不加`/`），这样就叫做匿名/具名挂载，挂载出来的内容会默认挂载到本地docker的目录下

通过匿名/具名挂载出来的内容可以通过`docker volume ls `看到

![image-20211117213342965](https://s2.loli.net/2021/12/06/FauCUbQYMD4v5ck.png)

同时我们也可以通过`docker volume inspect [挂载名称]`来查看详细信息，通过`rm`来删除某个不被容器使用着的挂载卷，其他更多操作指令详见`–help`

更进一步的我们还可以在挂载目录后加`:ro`，这样的话容器内部挂载出来的目录就只能够在宿主机内修改，我们进入容器就修改不了内容了

![image-20211117214737924](https://s2.loli.net/2021/12/06/byx9TiEUCvnmIOw.png)

利用这种机制，虽然各个容器间是隔离的，但是我们可以通过将两个容器挂载到宿主机下的同一目录来实现容器间的数据互通

## Docker配置文件

Docker配置文件（DockerFile）是用来构建docker镜像的文件，也就是说我们可以预先配置一个统一的Docker配置文件，然后不需要通过之前说过的`run+修改+commit`的操作来生成一个自己的镜像，现在我们只需要通过一个`build`命令构建一个新的镜像时引用一个Docker配置文件，Docker就可以自动读取文件内容并且直接对某一个目标镜像进行修改，并且创建一个新的自定义镜像，这个镜像就包含我们在Docker配置文件中写入的自定义内容

事实上，几乎我们能够找到的所有官方镜像都是通过这种方式来构建出来的（一般官方引用的模板镜像叫做`scratch`），只不过相较于我们改动较少的内容，他们需要在Docker配置文件中配置更多的内容

接下来我们详细了解一下Docker配置文件有怎样的常用指令

- `FROM [引用镜像]`我们自定义出来的镜像引用什么镜像为模板，即如果Docker配置文件里面只有这一句话，我们所创建出来的镜像将会和引用镜像一模一样

- `MAINTAINER [作者信息]` 没什么好讲的，标注一下这个镜像是我制作的

- `RUN`也就是当我们通常`run`起来的时候在bash里面将会输入命令，但是他会创建一个新的镜像层（联合文件系统），因此常用作安装某些软件包

- `CMD`和`RUN`类似，但是不会创建新的镜像层，同时它的命令会被用户创建容器`run`时如果输入的命令所覆盖

- `ENTRYPOINT`和上面两个都很类似，比起`CMD`不会创建新镜像层之外，也不会被用户`run`的时候输入的指令覆盖，而是会追加在用户命令之后，即它所修饰的指令一定会被执行

- `ADD/COPY`两个指令功能类似，用于添加镜像需要的一些内容，例如一个环境的集成压缩包

  > 但是`ADD`除了能够完成所有`COPY`的工作，还可以解压压缩文件并拷入镜像和通过URL拷贝文件到镜像（但是官方不建议），功能更加强大

- `WORKDIR`设置运行时的工作目录，即我们第一次进入容器后bash所指向的目录

- `VOLUME`自动设置一个容器卷，自动将镜像下的某个目录挂载到宿主机（匿名挂载）

- `EXPOSE`对外提供的端口，免去了创建容器时的手动暴露端口

- `ENV`设置环境变量，比如一个ES环境需要一大堆的内存空间，然而我们的空间远远不够，可以设置环境变量来控制ES运行时最大可占用内存的大小

常用指令就是这样，非常好理解，等于说是我们写了一个脚本，自动将某一个镜像创建成容器后执行一大堆我们的命令之后再`commit`回一个镜像还给我们

比如我们现在有一个这样的DockerFile

![image-20211122235856270](https://s2.loli.net/2021/12/06/9Dt82TNwpOobnBF.png)

> 这里写错了，ubuntu不能用yum下载文件，同时由于新创建的ubuntu镜像不包含最新源的`apt-get`，所以还需要`apt-get update`一下
>
> 最终代码为
>
> ```bash
> MAINTAINER chillyblaze
> 
> ENV MYPATH /home  # 注意这里环境变量一定不要手贱设个叫PATH的，直接覆盖了原有的环境变量，后果很严重!
> WORKDIR $MYPATH
> 
> RUN apt-get update
> RUN apt-get install vim
> 
> EXPOSE 1111
> 
> CMD echo $MYPATH
> CMD /bin/bash
> ```
>
> > 这个环境变量就可以看作是windows里面设置的path，之后我们可以通过这个环境变量快速访问到相关内容
> >
> > 事实上我们在linux内输入的所有指令都是以环境变量存在着的

我们要将其构建出来

![20211124232558.png](https://s2.loli.net/2021/12/06/ahgpIKeqyb89O2B.png)

如果不出问题的话最后会提示我们构建成功的字样，此时我们可以检查一下镜像

![20211124233300.png](https://s2.loli.net/2021/12/06/aRxVSCwNIyczH5W.png)

如果还不放心可以构建容器`run`看看是否和我们预想当中一致

![image-20211124234018255](https://s2.loli.net/2021/12/06/tMLve7B6WxTgrRO.png)

> 还可以通过`vim -version`查看当前vim版本（忘截了）

如果还是好奇，则可以通过`docker history [容器id]`来查看构建这个容器之中的所有历史内容

![image-20211128202430053](https://s2.loli.net/2021/12/06/8UeRPradQu6SOcl.png)

可以看出来就是我们在文件中编写的每一条内容，他都完整的执行了

## 发布自己的镜像到DockerHub

和GitHub非常像，首先我们也要在Dockerhub上面创建一个账号

![image-20211128210706788](https://s2.loli.net/2021/12/06/1k7bQo4hADglCX8.png)

接着我们在本地登录上我们的这个账号

![image-20211128214051838](https://s2.loli.net/2021/12/06/mwhg3AFCbZaR4Mc.png)

接着就可以通过`push`命令提交镜像

当然为了使我们提交的镜像到指定的仓库，我们必须通过tag命令修改原本的镜像名

> 其实会发现所谓的镜像名其实就是镜像存放的仓库名，所谓的镜像名其实不存在，有名字存在的只是我们的容器名

![image-20211128212514837](https://s2.loli.net/2021/12/06/sqPY8NdE4GOCjtX.png)

![image-20211128212710510](https://s2.loli.net/2021/12/06/j7ZqHPAKXJaER9C.png)

> 反转了，其实不是重名问题，由于我们登录的是chillyblaze这个账号，因此必须指定前缀仓库为我们的用户名才可以（类比于GitHub我们建的仓库名路径），上面解释错了

接着打开DockerHub进入我们的仓库中就可以发现我们推送上去的内容了

![image-20211128213755149](https://s2.loli.net/2021/12/06/gI3mlG6xzydfwEN.png)

## Docker网络

Docker为我们提供了专属于自己的内部Docker网络，相关的容器可以通过内部的网络进行连接

我们可以通过`ip addr`来查看当前的网卡信息

![image-20211130181237933](https://s2.loli.net/2021/12/06/okZnJAEQiqNXGms.png)

为了验证我们的猜想，比如我们先开启一个Tomcat

```bash
docker run -d -P --name tomcatTest tomcat
```

接着我们可以通过交互模式执行`ipconfig`或者是`ip addr`指令来查看容器在Docker网络内的IP地址

![image-20211130220818893](https://s2.loli.net/2021/12/06/PWURhAHVYkXendg.png)

> 如果报错了的话就进到tomcat里面下一个`iproute2`，注意容器内可能是`Debian`系统，得用`apt`来下载内容

这就像是我们在电脑上启动了一个虚拟机，理所当然的我们在本机可以通过虚拟机上的ip地址来访问到虚拟机

![image-20211130183612006](https://s2.loli.net/2021/12/06/lC8RyXEULjGPHK9.png)

如上图ping通也一点问题没有，事实上不仅如此，容器相互之间也可以通过这个ip地址互相ping通，此时我们本机就相当于家中的一个路由器，每一个容器就是家里的各种设备，各个设备之间可以ping通也一点都不奇怪

### veth pair

在上边的测试中我们发现，每开启一个Docker容器，本机上就会多了一对网卡，分别位于容器内和本机上，正由于这两个网卡之间的相互连接，使得我们可以无障碍ping通容器，这个技术就是所谓的veth pair技术

veth pair提供了一对虚拟网卡，像是一对对讲机一样，连接相互隔离的两个网络协议栈（也就是我们此处的Docker容器和本机）

![image-20211130224235081](https://s2.loli.net/2021/12/06/KB7hpWV1PU4IJDg.png)

通过这幅图的辅助，我们就能理解，当每创建一个Docker容器，Docker就会生成一对虚拟网卡（也叫虚拟网络接口），分别放置到容器内和本机上，同时在容器内给这个网卡分配一个IP地址（127.0.0.2），而在本机将这个虚拟网卡连接到`docker0`网络地址（127.0.0.1），这样我们就可以通过这一对网卡实现点对点的连接

如果有多个容器存在，虽然容器之间相互隔离，但是此时本机（也就是`docker0`网卡）就相当于一个路由器（也就是Docker网络的网关），容器内的请求首先被转发到`docker0`上，再由`docker0`寻找转发的IP地址将请求转发到另一个容器内，也正是这样实现了容器相互之间的通信

而`docker0`除了作为网关以外还兼具网桥的功能，这个在本机上建立的小小的Docker网络与我们外界通信的入口就是`docker0`，从这个意义上来说，当我们在本机中ping一个容器时，其实也是先经过了`docker0`的转发，才得以传输到目标容器中

> *网桥也叫桥接器，是连接两个局域网的一种存储/转发设备，它能将一个大的LAN分割为多个网段，或将两个以上的LAN互联为一个逻辑LAN，使LAN上的所有用户都可访问服务器。*
>
> 通俗来说，就是整合两个局域网的一个中间件，在此处，Docker网络和我们本机物理网卡上的网络就可以看作两个局域网

### 自定义docker网络

在了解了`docker0`的运作规律之后，我们就可以尝试自己构建一个docker网络，事实上，在实际开发中，我们更多的使用我们自定义的网络进行容器间通信，相较于通过默认的`docker0`进行通信具有一定的优越性

首先我们可以通过`docker network ls`来列出Docker默认的可选网络

![image-20211201153135620](https://s2.loli.net/2021/12/06/sbdmQF5Rxevw7St.png)

其中的`DRIVER`就是建立的网络模式，每一个条目可以看作一个局域网，当我们启动一个容器时，我们可以通过`–net [NAME]`来指定当前创建容器将其置于哪个网络下，如果不指定，默认就走`bridge`这个网络，也就是`docker0`

了解了这些之后，我们就可以通过`network create`来创建一个自己的网络

![image-20211201153936033](https://s2.loli.net/2021/12/06/qPsHJiQBegc9Utj.png)

创建完成后，我们可以再次创建一个tomcat容器，指定其网络组名称，并查看其网卡情况

![image-20211201155116387](https://s2.loli.net/2021/12/06/WefiZjxvqRY6mNn.png)

![image-20211201155121116](https://s2.loli.net/2021/12/06/dJPyNMvamtHr8kw.png)

这样我们的容器就成功的被放入了我们自定义的网络中，这个网络和docker网络别无二致，此外如果我们为创建的容器指定了名字，这个网络下的容器还可以通过名字当作一个域名一样直接解析成相应IP进行访问

同时拥有了自己的docker网络，就可以在不同的网络中创建不同的集群，降低了相互集群之间的耦合性，便于维护

### 网络间连通

此时我们可能会想，假设我们创建了多个网络，相互网络之间如何进行通信呢？

事实上，Docker也提供了一种容器连通不同网络的办法，只需要通过`connect`连接即可

![image-20211201160628857](https://s2.loli.net/2021/12/06/n27DGQV5A93TpvE.png)

如此可以发现实现的方式十分简单，只需要在现有的容器上再加一个veth接口，并让目标网络给他再分配一个IP地址即可，使得容器在不同的网络中有着不同的IP，由于网段的不同，也不存在出现矛盾的情况，真正实现了容器打通各个网络

## 容器外连接

我们可能会发现，其实容器内什么指令几乎都没有，要运行控制台调试显得特别麻烦，甚至还需要额外下载内容，原本精简的容器莫名其妙就变得臃肿了，显然十分不方便，那么我们可不可以从容器外的指令控制容器内的显示呢

别说还真可以，我们首先要了解到命名空间的概念

***Linux 命名空间对全局操作系统资源进行了抽象，对于命名空间内的进程来说，他们拥有独立的资源实例，在命名空间内部的进程可以实现资源可见。对于命名空间外部的进程，则不可见，实现了资源的隔离。这种技术广泛的应用于容器技术里。***

资源隔离的技术十分常见，同时还可以细分为UTS，IPC，PID，Network，Mount，User等，而Docker所采用的即是基于网络栈的资源隔离（Network）

Docker内的进程隔离也是同理，当启动一个容器时，在主机上看其实只是起了一个进程，因此在容器内部，也就只能看到自己内部的进程了

我们可以通过`docker inspect --format "{{ .State.Pid }}" [name]`来查看容器在宿主机上的进程号，其中两个花括号代笔监视之后显示的json中的某个键，其中键名以`.`开头，后面注意第一个字母大写即可

找到了容器启动时的进程号，我们就可以通过`nsenter`指令来执行容器内的某指令，比如这样`sudo nsenter -n -t 4314 ip addr `就可以查案容器内的端口号，但实际上容器内并没有`ip addr`这个指令

但注意这样的执行方式只能适用于网络命令，如果使用比如`ps -ef`之类的读取目录指令实际上显示的内容还是宿主机中的内容

借助这个命令我们可以对容器内比如mysql进行抓包操作

```shell
sudo nsenter -n -t 4341 ip addr
tcpdump -i lo port 3306 -w mysql.pcap
```

即可