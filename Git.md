# Git

Git是一个**开源的分布式版本控制系统**，可以有效、高速地处理从很小到非常大的项目版本管理。

> 版本控制就是某个可以保存老版本并且实时更新新版本的控制系统

## 对比SVN

SVN也是一个版本控制的工具，但是利用的是集中式的版本控制，会将所有的更新代码保存在统一的服务器上，多人协作进行开发时，每个开发者从统一的资源路径下取得最新的版本进行修改和提交

但是这种方案有一个问题，由于每个用户都得去中央服务器中取得版本内容，一旦中央服务器崩了，每个开发者就不能实时获取到最新的内容

这也就诞生了Git，也就是分布式版本控制，所有版本信息仓库全部司步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push（同步）到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据。这样就不会因为服务器损坏或者网络问题，造成不能工作的情况！

**分布式版本控制的特点就是用户之间可以互相从别人那里更新所有版本内容**

## Git安装

先从官网下载最新版本，然后安装的时候实在不行一直点下一步就可以了

安装完成后菜单里会多出来几个东西（如果勾选了添加到菜单的话）

- Git Bash：是Linux风格的命令行，使用最多
- Git CMD：Windows风格的命令行，和上面那个就只有命令代码之间的区别，配置到环境变量之后直接可以在cmd里面使用
- Git GUI：图形化界面，不建议使用

## Git基本原理

Git本地有四个工作区域：

- 工作区（Workspace）：即我们开发中各种的项目文件，
- 暂存区（IndexStage）：是一个`index`文件，里面跟踪了我们曾经`add`进去的文件快照（`add`可以理解为文件保存），使得当内容被放入暂存区之后，即使我们更改了工作区内的内容，暂存区中仍存放着我们上一次`add`的内容，但是与资源库不同的是每一次`add`的记录本身将不会被保存
- 资源库（Repository）：本地的代码库，由一个个分支（HEAD指向的即为当前分支）组成，我们在暂存区的内容通过`commit`提交到某一个分支中，添加了提交信息之后这一次提交记录和当前的项目快照将会被永久保存
- 远程库（Remote）：代码托管的服务器，即GitHub

其实我们需要打交道的就是工作区和远程库，暂存区和资源库一般理解里都在项目的`.git`目录中

文件在这四个区域之间的转换关系如下，每一个关系就是一条命令

![image-20211111094931370](https://s2.loli.net/2021/12/05/p5lqMBG9cL2XhRH.png)

## 本地bash指令

git里面的命令都以git命令开头，下面的命令都省略git代码

- 使用git第一步是对其进行必要的配置，可以通过`config..`进行配置操作

  - `-l`列出配置清单

  - `--system --list`列出系统配置的内容

  - `--global --list`列出用户配置的信息

    > 注意系统的配置内容在`git/etc/gitconfig`文件内
    >
    > <img src="https://s2.loli.net/2021/12/05/5a1r83iUsAcmI4S.png" alt="image-20211027210917502" style="zoom: 37%;" />
    >
    > 而用户的配置则都在`user/.gitconfig`文件中
    >
    > <img src="https://s2.loli.net/2021/12/05/nMoTQwiBhCYcO3g.png" alt="image-20211027211043285" style="zoom:50%;" />
    >
    > > 这里其实是我在安装的时候勾选了默认采用VSCode编辑器的缘故，也算是安装的时候自动配的文件

  - `--global user.name [用户名]`配置用户名，除此之外还需要配置`user.email`，如果想要之后提交到远程仓库时能够被远程仓库识别为你，就需要设置远程仓库的用户名和邮箱

    ![image-20211114000258025](https://s2.loli.net/2021/12/05/oTuaMF1LgtN4d67.png)

    设定完毕后可以通过`–list`查看正确性，之后也可以去之前的文件里看看是否添加成功

    ![image-20211027211919124](https://s2.loli.net/2021/12/05/h7KqmYzGC1tlrn8.png)

- 配置完成后我们就要创建一个仓库，我们可以选择创建本地仓库和克隆远程仓库

  - 创建本地仓库，就在将要创建仓库的地方打开bash，`git init`自动创建出最关键的`.git`目录

    ![image-20211028150906704](https://s2.loli.net/2021/12/05/E37AKGNWR4apZHY.png)

  - 克隆远程仓库，我们就先去GitHub上面随便选择一个项目，点击醒目的code按钮

    ![image-20211028151623795](https://s2.loli.net/2021/12/05/GqW7n6vVc2BTZUj.png)

    复制下这段链接，我们在仓库文件夹中同样打开bash，`git clone [url]`即可克隆远程仓库

    > 可能会遇到无法连接的情况，这时候就需要万能的代理出手
    >
    > ```bash
    > git config --global http.proxy "http://127.0.0.1:7890"
    > git config --global https.proxy "https://127.0.0.1:7890“
    > ```
    >
    > 记得在clash里面打开允许局域网连接，同时这里设置的值前缀还可以改成`socks5`，注意端口一定要写对，同时注意就算代理了流量也是ping不通的（因为ping操作走的不是http协议）

- 完成本地仓库的设置之后，我们就可以对其中的文件进行文件操作

  - `status`查看当前git目录下的各个文件状态，`untracked`代表的就是只在工作目录下未添加到暂存区，同时还可以在后面跟上文件名对某一文件的状态进行特定显示

    ![image-20211029103548701](https://s2.loli.net/2021/12/05/8c4slAn6I3kWmOM.png)

  - 这时候如果我们想添加到暂存区，只需要`add .`即可提交所有文件到暂存区

    ![image-20211029103905818](https://s2.loli.net/2021/12/05/BFpP6k5Da17tUqd.png)

  - `commit -m`将暂存区中的文件提交到本地仓库，并添加备注信息（必需）

    ![image-20211113102259458](https://s2.loli.net/2021/12/05/Wlr36y1HFbIq8do.png)

    > 这里变化了git项目位置，但是不要紧，之前的操作都没变，仅为之后的联动远程仓库做准备

  - 同时还可以通过`status --short`简短但是有效的显示当前目录下的所有内容状态信息

    假设当前突然修改了已提交的1.txt文件的内容，再次查看时会变成这样

    ![image-20211113104111510](https://s2.loli.net/2021/12/05/2mh7YUCHqzrcaPO.png)

    红字表示该文件已被跟踪，但是把**当前工作区的文件内容**（下层区）和**之前暂存的文件**（上层区）进行比对并不一致，因此提示`modified`（文件被修改但未暂存`add`），这时候通过`status --short`展示如下

    ![image-20211113104429000](https://s2.loli.net/2021/12/05/k2nuXwz7csErA9F.png)

    发现文件前面第二位出现了红色的M，接下来我们对修改后的文件进行重新add，再次查看

    ![image-20211113104551374](https://s2.loli.net/2021/12/05/6OhcFvuCreRt2xS.png)

    发现M变成了第一位而且变绿了，这其实表示的是git将**当前暂存的文件**（下层区）和**资源库内之前提交的文件**（上层区）进行比对发现不一致，因此同样是提示`modified`但是含义不同（文件被修改但未提交`commit`）

    自此，我们了解了`--short`两位状态码XY（分别对应上面的绿M位和红M位）的位置含义，即代表暂存区和另外两个区哪个区比对之后的结果展示，除了M之外其实面对文件发生状态的不同还会有另外的字母，以下是官方的介绍

    - ' ' = unmodified
    - *M* = modified
    - *A* = added，下层区出现新的文件但是上层区没有这个文件（仅出现在第一位）
    - *D* = deleted，下层区把文件删掉了但是上层区还留有上次提交的副本
    - *R* = renamed，下层区文件被改名了
    - *C* = copied，不是很重要
    - *U* = updated but unmerged，未合并（合并和分支有关，详见后边）
    - *??* = 未被跟踪的文件
    - *!!* = 被忽略的文件

  - `log [文件名]`当我们已经提交一个文件之后就无法通过`status`定位文件的状态，这时候就需要通过`log`指令展示所有的提交记录和其他提交信息（提交用户，邮箱等），当然也可以通过加文件名的方式查看某一个文件的提交记录

    ![image-20211113102930064](https://s2.loli.net/2021/12/05/9SPwFo4dTZMXNUI.png)

    > 还可以用`shortlog`查看简短的提交信息

这样最简单的git指令就已经差不多搞定了，但是我们会发现上面的add和commit命令其实会提交所有文件，但是有些文件我们不想要提交，这时候就需要通过添加忽略文件（`.gitignore`）

> 我们会发现之前建立SpringBoot项目的时候会自动生成这个文件

随便在网上搜一个`.gitignore`文件配置就可以了，里面可以排除相关的文件，不将其add到暂存区，也就不会被commit全部提交上去

## 分支，合并和冲突

*几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。*

*有人把 Git 的分支模型称为**必杀技特性**，而正是因为它，将 **Git** 从版本控制系统家族里区分出来*。

<p align="right"><i>——菜鸟教程</i></p>

当我们了解完如何提交自己的代码到远程之后，实际上这只是一个开始，也是一个不成熟的提交操作，在实际的开发中，我们必须运用分支+合并的方式对一个项目进行维护和添加功能，即当我们需要给项目添加某个功能但是并不清楚是否会发生错误导致整个项目崩溃时，就可以在主分支下创建一个新的分支，新的分支创建时默认会拥有当前分支的所有信息，在新分支中添加完新功能并测试成功之后再将其安全的合并到原有项目中

不仅安全方面有保障，在我们给新分支中添加新东西时，原本的主分支仍旧在以旧版本正常运行，直到我们将内容合并到主分支中，一定程度上也实现了主分支版本的更替

- `branch`可以查看当前分支信息，加上`-v`则可以看到详细信息，后面加上分支名则可以创建一个新的分支，`checkout [分支名]`可以切换到指定分支

  ![image-20211113145506631](https://s2.loli.net/2021/12/05/cfCa7iVgXTmydv8.png)

  > 这里省略了上面的修改后的commit操作

- 之后比如说我们修改了1.txt文件，并把修改后的1.txt提交到`feature_test`分支的资源库下，再次查看分支信息

  ![image-20211113150336201](https://s2.loli.net/2021/12/05/6AWUcfvz5VFJm9d.png)

- 这时候如果`feature_test`的功能已经开发完毕，则我们需要将其合并到主分支master当中

  注意，想合并到哪个分支，比如现在想合并到主分支，就应该切换到主分支下操作合并动作

  ![image-20211113151124473](https://s2.loli.net/2021/12/05/MCV2zyDtf1l69WP.png)

- 但是分支的合并一般也不是一帆风顺的，比如现在两个分支中分别有不一样的内容且无法合并时

  ![image-20211113152135303](https://s2.loli.net/2021/12/05/qL9OnIo8JdHmZ7k.png)

  很明显能看出，1234和1235两个内容是没有办法一下子合并的，这时候就会出现冲突警告

  ![image-20211113152410494](https://s2.loli.net/2021/12/05/lF5bAHN6mG3yEhc.png)

  这时候我们打开`1.txt`会发现内容已经变成了奇怪的样子

  ![image-20211113152808107](https://s2.loli.net/2021/12/05/7qE8TaSbVtzPfhJ.png)

- 这时候我们应该对内容进行人工审核并保存最终审核内容（比如此处保存123)，重新提交一次即可解决冲突问题

  ![image-20211113155133877](https://s2.loli.net/2021/12/05/7BZsnQrCv5gUwY9.png)

同时当我们合并完一个分支之后，一般来说我们会删去合并来的分支达到项目的足够精简，同时git也建议我们能够删去已经被合并到其他分支的冗余分支

![image-20211113203644908](https://s2.loli.net/2021/12/05/gUyRLzcjCZ52TqD.png)

上图可以发现，在删除分支前git会自动帮助我们比对同一目录下的其他分支，看看这个被删除的分支是否真的已经合并到了别的分支中，如果没有完全被合并，则会提醒我们

## ssh连接远程仓库

由于我们平时工作在本地仓库，想要提交到远程仓库就要和其建立连接，所以我们要设置本机绑定SSH公钥，实现免密码登录Github

由于之前连接虚拟机的时候使用过ssh，因此我已经创建过公钥了，直接在`C:\Users\Lenovo\.ssh\id_rsa.pub`拿来用即可，复制好之后进入github设置里面添加新的SSHKey，标题随便写，下面的Key复制进我们之前复制的公钥，点击保存

![image-20211029123841638](https://s2.loli.net/2021/12/05/XVTkNx5HvyhsCPK.png)

连接好之后打开Bash，`ssh -T git@github.com`测试连接状况

![image-20211029124047930](https://s2.loli.net/2021/12/05/tiRr5YOAEK1pTsJ.png)

## 本地&远程仓库协同运作

上面介绍了本地如何创建一个git仓库并提交到本地的资源库，同时也成功连接了远程的仓库，这时候如何能够使本地和远程仓库相配合，从而对我们的项目进行完整的版本控制就是一个问题

### 推送本地内容至远程

1. 首先确定当前的本地和远程仓库情况，并做一些初始准备

   - 本地仓库已提交了一个`1.txt`文件到资源库
   - 本地仓库已连接到远程仓库，并且测试连接成功

2. 创建一个空白的远程仓库（以GitHub为例）

   ![image-20211113112220762](https://s2.loli.net/2021/12/05/KivMAa2N4koxPIj.png)

   

3. 从本地创建一个远程库别名，这样我们不需要记一长串地址就能够直接提交到远程库

   ![image-20211113140820028](https://s2.loli.net/2021/12/05/5goMsQUVmWIxnbc.png)

   > 其中的地址就是之前我们clone的时候复制的地址

4. 本地直接`push [目标远程仓库别名] [本地分支]`到该仓库即可将资源库里面的内容全部上传到远程

   ![image-20211113161715515](https://s2.loli.net/2021/12/05/oTBrbHQ3Kzy5Fiq.png)

   之后我们打开GitHub刷新仓库内容，即可发现我们的文件已经被推送到远程了，包括我们所有的commit记录

   ![image-20211113162014245](https://s2.loli.net/2021/12/05/6AuckLeZaSOw9Wo.png)

这时候，暂存区，资源库，远程仓库分别是三个独立的运作系统，正常情况下每一个区当中都保有一份当前的项目内容，无论哪个部分出现故障，都能保证整体内容不出差错

有人可能会想，在这种情景下如果我们又回到了`feature_test`分支推送内容到GitHub，会发生什么事情呢

![image-20211113164331008](https://s2.loli.net/2021/12/05/LnrD3TVMgRtjpqu.png)

![image-20211113164549506](https://s2.loli.net/2021/12/05/Hym4XzE6nMsTIJR.png)

远程也确实增加了一个分支，但由于本身我们推送的master分支就是由这个分支合并而来的，因此master分支拥有`feature_test`分支所有的commit和内容改动，即为`feature_test`的超集，因此这两个分支相安无事

GitHub也在线上提供了一个给予我们合并两个类似分支的方式，假设现在我们的两个分支存在相似和可合并之处，我们就可以人为的通过上方的`Pull requests - New pull request`来合并两个分支

![image-20211113165045827](https://s2.loli.net/2021/12/05/VewAzg5IhPci7kn.png)

![image-20211113165320939](https://s2.loli.net/2021/12/05/OehYaz6dbiprH9j.png)

至于真的出现了冲突需要修改，实际上和之前的分支合并操作是完全一样的，此处略

### 抓取远程内容并合并

学习了如何推送本地资源库内容至远程仓库，还有一个很重要的就是如何从远程仓库中拉取别人更新的内容并合并到本地，这在实际开发中也是不可或缺的，不可能所有人在一条流水线上工作，当我们花了很多时间做好一个更新内容的时候，可能在这期间别的人做好了别的新功能，已经推送到远程并更新了远程仓库，这时候就需要我们重新下载远程仓库的更新内容，与自己更新的内容进行合并，之后将整合好的所有内容再一次推送到远程

这非常符合逻辑，但是之前提到的`clone`是可以拷贝远程内容到本地，但是好像并不能做到和我们本地当前内容进行比较，这时候就需要`fetch+merge`出手

![image-20211113190849311](https://s2.loli.net/2021/12/05/1tPURv8VbgMDAQ4.png)

![image-20211113190558402](https://s2.loli.net/2021/12/05/VDnv6L2osr4GSdY.png)

可以看出`fetch`即是相当于将远程仓库中的内容以分支的形式克隆了下来，相关内容保存在`origin/[远程分支名]`这个虚拟分支中，我们可以查看其内的代码变化，修改到没有问题之后再切换回本地分支进行合并

![image-20211113191953164](https://s2.loli.net/2021/12/05/qz2iFPopVtOh8E6.png)

> 其中switch和checkout在此处功能相同，只是新版本git的新特性

同时执行了`fetch`命令之后会发现`.git/refs`目录下出现了一个`remotes`的目录，这个目录和上面的`heads`目录功能类似，都是用来记录和跟踪某个分支的，这里跟踪的即是远程仓库中的分支信息，便于我们进行合并

同时通过`branch -a`可以查看目前目录下所有分支（`-r`可以仅看远程`fetch`来的分支）

![image-20211113193150189](https://s2.loli.net/2021/12/05/RfLdzrpj9Oi1PSX.png)

-----

这样对Git也算有了一个大概的了解，事实上，Git除开介绍的正向提交内容并更新之外，更为强大的是其基本不会导致历史记录丢失的回滚能力，Git发明的目的就是保证在项目启动之后任何一个阶段的内容都不会真正意义上的消失，只要需要无论什么时候都可以方便的找到历史中的任意一个切片时间上的内容

当我们对Git有整体的印象之后，如果遇到了上述情况，如急需找到某一时期的提交内容，我们就可以运用自己的检索能力快速定位到所需要的指令内容，从而实现对任何数据的修补工作

## 多人协作工作流

### 预备工作

在此之前，为了避免发生一些错误，我们得做一些预备工作

1. 设置项目代理，为了避免连接不上github，当然也可以设置全局的代理

   ```shell
   git config  http.sslVerify false                     
   git config  http.proxy https://127.0.0.1:7890
   git config  https.sslVerify false                     
   git config  https.proxy https://127.0.0.1:7890
   ```

2. 设置全局ssh登录，避免使用弱智的http协议

   ```shell
   git config --global url."git@github.com:".insteadOf https://github.com/
   ```

   之后测验一下`ssh -T git@github.com`能不能正常运行，如果出问题请移步上方

3. 开启原基pull模式，或者选择不开启，但是一定要选，不然出现冲突pull时会报错

   ```shell
   git config pull.rebase false
   ```

4. 打开vscode，下载gitlens，测试一下功能

   ![image-20220416152510786](https://s2.loli.net/2022/04/16/NqvPDb3pkxncl8I.png)

### 项目管理

项目管理有几个不同的工作模式，分别如下

- **直接提交模式**

  clone之后本地直接在main分支上进行操作，并提交和推送，其中可能会出现push失败的情况但是没有关系，通过pull对冲突内容进行合并和修改，之后在本地对内容进行commit，然后再push即可

  如果开启原基模式，则会进入到rebasing模式，在此状态下同样也是对冲突文件进行修改并add，但是此时不再是commit。而是选择`git rebase --continue`退出原基模式，之后会让你输入提交信息一类的内容，输入完之后即可正常push

- **合并分支模式**

  在clone了某个仓库之后，立刻在本地创建一个dev分支，并保留clone之后别人的main主分支，所有的更新操作在dev分支上进行，当完成任务之后，切换到main分支进行pull（由于从来没有更改过主分支，因此此时主分支一定可以成功pull），接着再通过merge操作合并dev分支到主分支，删除dev分支，并push主分支

- **Fork+PR模式**

  除了在本地可以进行合并操作之外，如果仓库并不属于你个人，此时就需要在github上管理合并冲突内容，我们需要先fork一下别人的仓库，或者在github上创建一个新的分支，接着我们所有的操作都在这个fork出来的仓库或者新的分支上进行，同时注意push同样也是push到这个新的内容中，紧接着在网页中点击`Pull requests`新建一个PR请求，在上面选择好自己的仓库或者是分支，点击`Create pull request`即可



